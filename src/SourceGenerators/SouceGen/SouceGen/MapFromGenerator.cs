using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace SouceGen;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class MapFromGenerator : IIncrementalGenerator
{
    private const string Namespace = "SouceGen";
    private const string AttributeName = "MarketDataBitConverterAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>
using System;
namespace {Namespace}
{{
   // 数据类型枚举
public enum MarketDataType
{{
    None,
    Int8, // 8 位有符号整数
    UInt8, // 8 位无符号整数
    Int16, // 16 位有符号整数
    UInt16, // 16 位无符号整数
    Int32, // 32 位有符号整数
    UInt32, // 32 位无符号整数
    Int64, // 64 位有符号整数
    UInt64, // 64 位无符号整数
    Float, // 单精度浮点数
    Double, // 双精度浮点数
    String, // 字符串（固定长度）
    Char, // 单个字符
    Bool, // 布尔值
}}
// 自定义特性类
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public class {AttributeName} : Attribute
{{
    public MarketDataType Type {{ get; set; }} // 可选，指定数据类型
    public int Offset {{ get; set; }}     // 必选，偏移量
    public int Length {{ get; set; }}     // 必选，长度

    public MarketDataBitConverterAttribute(int offset, int length, MarketDataType type = MarketDataType.None)
    {{
        Offset = offset;
        Length = length;
        Type = type;
    }}
}}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 添加  MarketDataBitConverterAttribute .
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "MarketDataBitConverterAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // 筛选名为 MarketDataField 的类，并获取符号
        var classSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is RecordDeclarationSyntax cds && cds.Identifier.Text == "MarketDataField",
                transform: (ctx, _) =>
                {
                    var classDeclaration = (RecordDeclarationSyntax)ctx.Node;
                    var semanticModel = ctx.SemanticModel;
                    var symbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                    return symbol;
                })
            .Where(x => x != null);

        // 注册源代码输出
        context.RegisterSourceOutput(classSymbols, (spc, symbol) =>
        {
            if (symbol == null) return;

            string source = GenerateMapFromMethod(symbol);
            spc.AddSource("MarketDataField_MapFrom.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private string GenerateMapFromMethod(INamedTypeSymbol symbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using MarketDataParser.Internal;");
        
        sb.AppendLine();
        sb.AppendLine($"namespace MarketDataParser.Parsers;");

        // 生成 partial record 并包含 MapFrom 方法
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"public partial class MarketDataFieldBitConverterSourceGen");
        sb.AppendLine("{");
        sb.AppendLine("    public  static MarketDataField MapFromBytes(in ReadOnlySpan<byte> bytes)");
        sb.AppendLine("    {");
        sb.AppendLine(
            "       if (bytes.Length < 312)\n        {\n            throw new ArgumentException(\"字节数组长度不正确，至少需要 312 字节。\");\n        }");
        sb.AppendLine("        var field = new MarketDataField();");

        // 获取带有 MarketDataBitConverterAttribute 的属性
        var properties = symbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.GetAttributes().Any(a => a.AttributeClass.Name == "MarketDataBitConverterAttribute"));

        foreach (var property in properties)
        {
            var attribute = property.GetAttributes()
                .First(a => a.AttributeClass.Name == "MarketDataBitConverterAttribute");
            var offset = attribute.ConstructorArguments[0].Value;
            var length = attribute.ConstructorArguments[1].Value;
            var type = attribute.ConstructorArguments.Length > 2
                ? (MarketDataType)attribute.ConstructorArguments[2].Value
                : MarketDataType.None;

            string parseCode;
            string propertyType = property.Type.ToString();

            // 根据特性中的 Type 或属性类型生成解析代码
            if (type != MarketDataType.None)
            {
                parseCode = GetParseCodeByType((MarketDataType)type, offset, length);
            }
            else
            {
                parseCode = GetParseCodeByPropertyType(propertyType, offset, length);
            }

            if (property.Name == "CheckFlag")
            {
                sb.AppendLine($"        field.{property.Name} = (uint){parseCode};");
            }
            else
            {
                sb.AppendLine($"        field.{property.Name} = {parseCode};");
            }
            
        }

        sb.AppendLine("        return field;");
        sb.AppendLine("    }");
        sb.AppendLine(@"/// <summary>
    /// 添加读取字符串辅助方法
    /// </summary>
    /// <param name=""bytes""></param>
    /// <returns></returns>
    private static string GetNullTerminatedString(ReadOnlySpan<byte> bytes)
    {
        // 找到第一个 null 字符的位置
        int length = 0;
        while (length < bytes.Length && bytes[length] != 0)
        {
            length++;
        }
            
        // 只解码到 null 字符之前的部分
        return Encoding.UTF8.GetString(bytes.Slice(0, length));
    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private string GetParseCodeByType(MarketDataType type, object offset, object length)
    {
        return type switch
        {
            MarketDataType.Int8 => $"(sbyte)bytes[{offset}]",
            MarketDataType.UInt8 => $"bytes[{offset}]",
            MarketDataType.Int16 => $"BitConverter.ToInt16(bytes.Slice({offset}, {length}))",
            MarketDataType.UInt16 => $"BitConverter.ToUInt16(bytes.Slice({offset}, {length}))",
            MarketDataType.Int32 => $"BitConverter.ToInt32(bytes.Slice({offset}, {length}))",
            MarketDataType.UInt32 => $"BitConverter.ToUInt32(bytes.Slice({offset}, {length}))",
            MarketDataType.Int64 => $"BitConverter.ToInt64(bytes.Slice({offset}, {length}))",
            MarketDataType.UInt64 => $"BitConverter.ToUInt64(bytes.Slice({offset}, {length}))",
            MarketDataType.Float => $"BitConverter.ToSingle(bytes.Slice({offset}, {length}))",
            MarketDataType.Double => $"BitConverter.ToDouble(bytes.Slice({offset}, {length}))",
            MarketDataType.String => $"GetNullTerminatedString(bytes.Slice({offset}, {length}))",
            MarketDataType.Char => $"(char)bytes[{offset}]",
            MarketDataType.Bool => $"BitConverter.ToBoolean(bytes.Slice({offset}, {length}))",
            _ => throw new NotSupportedException($"类型 {type} 不支持")
        };
    }

    private string GetParseCodeByPropertyType(string propertyType, object offset, object length)
    {
        return propertyType switch
        {
            "byte" => $"bytes[{offset}]",
            "sbyte" => $"(sbyte)bytes[{offset}]",
            "short" => $"BitConverter.ToInt16(bytes.Slice({offset}, {length}))",
            "ushort" => $"BitConverter.ToUInt16(bytes.Slice({offset}, {length}))",
            "int" => $"BitConverter.ToInt32(bytes.Slice({offset}, {length}))",
            "uint" => $"BitConverter.ToUInt32(bytes.Slice({offset}, {length}))",
            "long" => $"BitConverter.ToInt64(bytes.Slice({offset}, {length}))",
            "ulong" => $"BitConverter.ToUInt64(bytes.Slice({offset}, {length}))",
            "float" => $"BitConverter.ToSingle(bytes.Slice({offset}, {length}))",
            "double" => $"BitConverter.ToDouble(bytes.Slice({offset}, {length}))",
            "bool" => $"BitConverter.ToBoolean(bytes.Slice({offset}, {length}))",
            "char" => $"(char)bytes[{offset}]",
            "string" => $"GetNullTerminatedString(bytes.Slice({offset}, {length}))",
            "DateTime" => $"new DateTime(BitConverter.ToInt64(bytes.Slice({offset}, 8)))",
            _ => throw new NotSupportedException($"属性类型 {propertyType} 不支持")
        };
    }
}